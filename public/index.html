<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Shared Draw</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
        background: #000;
    }
    canvas {
      width: 100vw;
      height: 100vh;
      display: block;

    }
    .palette {
      position: fixed;
      bottom: 10px;
      left: 10px;
      display: flex;
      gap: 8px;
      z-index: 10;
    }
    .swatch {
      width: 20px;
      height: 20px;
      border: 1px solid grey;
      cursor: pointer;
    }
  </style>
</head>
<body>

<div class="palette" id="palette"></div>
<canvas id="c"></canvas>

<script src="/socket.io/socket.io.js"></script>

<script src="/socket.io/socket.io.js"></script>
<script>
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: true });

  ctx.imageSmoothingEnabled = false;

  // ---- SETTINGS ----
  const ERASER_COLOR = "#000000"; // black erases (background is black)
  const DRAW_W = 2;
  const ERASE_W = 6;

  // white stays a drawing colour
  const COLORS = ["#ffffff", "red", "navy", "magenta", "#000000"];
  let currentColor = COLORS[0];

  // ---------- Palette ----------
  const palette = document.getElementById("palette");
  function renderPalette() {
    palette.innerHTML = "";
    COLORS.forEach(col => {
      const b = document.createElement("button");
      b.className = "swatch";
      b.style.background = col;
      b.onclick = () => {
        currentColor = col;
        renderPalette();
      };
      palette.appendChild(b);
    });
  }
  renderPalette();

  // ---------- Canvas resize ----------
  function resizeCanvas() {
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();

    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;

    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.imageSmoothingEnabled = false;
  }
  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: Math.floor(e.clientX - rect.left),
      y: Math.floor(e.clientY - rect.top)
    };
  }

  // ---------- Pixel line ----------
  function drawPixelLine(x0, y0, x1, y1, color, w) {
    ctx.fillStyle = color;

    let dx = Math.abs(x1 - x0);
    let dy = Math.abs(y1 - y0);
    let sx = x0 < x1 ? 1 : -1;
    let sy = y0 < y1 ? 1 : -1;
    let err = dx - dy;

    while (true) {
      const r = Math.floor(w / 2);
      ctx.fillRect(x0 - r, y0 - r, w, w);

      if (x0 === x1 && y0 === y1) break;
      const e2 = 2 * err;
      if (e2 > -dy) { err -= dy; x0 += sx; }
      if (e2 <  dx) { err += dx; y0 += sy; }
    }
  }

  // ---------- Socket ----------
  const socket = io();

  function renderSeg(seg) {
    const rect = canvas.getBoundingClientRect();
    const w = seg.w ?? (seg.color === ERASER_COLOR ? ERASE_W : DRAW_W);

    const x1 = seg.nx1 != null ? Math.round(seg.nx1 * rect.width) : seg.x1;
    const y1 = seg.ny1 != null ? Math.round(seg.ny1 * rect.height) : seg.y1;
    const x2 = seg.nx2 != null ? Math.round(seg.nx2 * rect.width) : seg.x2;
    const y2 = seg.ny2 != null ? Math.round(seg.ny2 * rect.height) : seg.y2;

    drawPixelLine(x1, y1, x2, y2, seg.color, w);
  }

  socket.on("history", segs => segs.forEach(renderSeg));
  socket.on("segment", renderSeg);

  function emitSeg(x1, y1, x2, y2, color) {
    const rect = canvas.getBoundingClientRect();
    const w = color === ERASER_COLOR ? ERASE_W : DRAW_W;

    socket.emit("segment", {
      x1, y1, x2, y2,
      nx1: x1 / rect.width,
      ny1: y1 / rect.height,
      nx2: x2 / rect.width,
      ny2: y2 / rect.height,
      color,
      w
    });
  }

  // ---------- Drawing ----------
  let drawing = false;
  let last = null;

  function startDraw(e) {
    drawing = true;
    last = getPos(e);
    emitSeg(last.x, last.y, last.x, last.y, currentColor);
    drawPixelLine(last.x, last.y, last.x, last.y, currentColor,
      currentColor === ERASER_COLOR ? ERASE_W : DRAW_W
    );
  }

  function moveDraw(e) {
    if (!drawing || !last) return;
    const p = getPos(e);
    if (p.x === last.x && p.y === last.y) return;

    emitSeg(last.x, last.y, p.x, p.y, currentColor);
    drawPixelLine(last.x, last.y, p.x, p.y, currentColor,
      currentColor === ERASER_COLOR ? ERASE_W : DRAW_W
    );
    last = p;
  }

  function endDraw() {
    drawing = false;
    last = null;
  }

  canvas.addEventListener("pointerdown", e => {
    canvas.setPointerCapture(e.pointerId);
    startDraw(e);
  });
  canvas.addEventListener("pointermove", moveDraw);
  window.addEventListener("pointerup", endDraw);
  window.addEventListener("pointercancel", endDraw);
</script>


</body>
</html>
